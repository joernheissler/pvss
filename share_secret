#!/usr/bin/python3.8

from sys import argv
from pvss import PublicKey, Secret, SystemParameters, compute_challenge, SharedSecret, Share


class Poly:
    def __init__(self, coeffs):
        self._coeffs = list(coeffs)

    def __call__(self, x: int):
        return sum(coeff * (x ** j) for j, coeff in enumerate(self._coeffs))

    def __len__(self):
        return len(self._coeffs)

    def __getitem__(self, idx):
        return self._coeffs[idx]

    def __repr__(self) -> str:
        return 'Poly([' + ', '.join(str(coeff) for coeff in self._coeffs) + '])'


if len(argv) < 6:
    exit(f"Usage: {argv[0]} <params_file> <out_secret_file> <out_shared_file> <t> <pub_files...>")


with open(argv[1], "rb") as fp:
    params = SystemParameters.decode(fp.read())

out_secret_file = argv[2]
out_shared_file = argv[3]

# Number of shares required to reconstruct secret
t = int(argv[4])

pub = []
for pub_file in argv[5:]:
    with open(pub_file, 'rb') as fp:
        pub.append(PublicKey.decode(params, fp.read()))


# polynomials, chosen from Z_q
alpha = Poly(params.pre_group.rand for __ in range(t))
beta = Poly(params.pre_group.rand for __ in range(t))

## Secret to be shared
S = (params.G ** alpha(0)) * (params.H ** beta(0))

# Write secret to file
with open(out_secret_file, "wb") as fp:
    fp.write(Secret.create(params, secret=S).der)

# commitments for coeffs
C = [(params.g ** a) * (params.h ** b) for a, b in zip(alpha, beta)]

# Encrypted shares
Y = [(pi.pub0 ** alpha(i)) * (pi.pub1 ** beta(i)) for i, pi in enumerate(pub, 1)]

# X_i computed by prover
X = [(params.g ** alpha(i)) * (params.h ** beta(i)) for i in range(1, len(pub) + 1)]

# rand [0,q)
k = [(params.pre_group.rand, params.pre_group.rand) for __ in range(len(pub))]

# random commitments
r = [(
    (params.g ** ki[0]) * (params.h ** ki[1]),
    (pi.pub0 ** ki[0]) * (pi.pub1 ** ki[1]),
) for pi, ki in zip(pub, k)]

# challenge is computed by hash function
challenge = compute_challenge(params=params, coeffs=C, pubs=pub, commitments=X, shares=Y, randoms=r)
c = int.from_bytes(challenge, 'big')

# response
s = [(
    ki[0] + alpha(i) * c,
    ki[1] + beta(i) * c,
) for i, ki in enumerate(k, 1)]

shared_secret = SharedSecret.create(params=params, shares=[
    Share.create(params=params, pub=pub_key, share=share, resp=resp)
    for pub_key, share, resp in zip(pub, Y, s)
], coeffs=C, challenge=challenge)

with open(out_shared_file, "wb") as fp:
    fp.write(shared_secret.der)
